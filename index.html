function doPost(e) {
  var sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  var data = JSON.parse(e.postData.contents);
  
  if (sheet.getLastRow() === 0) {
    // Expanded Headers for Machine Learning
    var headers = [
      "Timestamp", "User Name", "Type", "Predicted", "Raw_DC", "Actual_Meter", 
      "Noise", "Absorbance", "PerfusionIndex", "UpstrokeTime", "BPM", 
      "Finger", "HbA1c", "CoefA", "CoefB", "Intercept", "Offset", "Waveform"
    ];
    sheet.appendRow(headers);
  }
  
  // --- NEW: BIOLOGICAL VALIDATION LAYER ---
  // We sanitize the incoming data to ensure the regression isn't corrupted
  var upstroke = parseFloat(data.upstrokeTime);
  var isValidBio = (upstroke > 40 && upstroke < 300); // Only allow human-possible times
  
  if (data.type === "REVIVE_REQUEST" || data.type === "GET_COEF") {
    var rows = sheet.getDataRange().getValues();
    var searchName = data.name.toString().toLowerCase().trim();
    
    var record = { 
      coefA: 12.5, coefB: 45.0, intercept: 65.0,
      syncCount: 0, personalOffset: 0, foundLatest: false, userFound: false
    };

    var syncPoints = [];

    // Iterate backwards to find the most recent SYNC data
    for (var i = rows.length - 1; i >= 1; i--) {
        // NEW: Filter by BOTH Name and Finger to ensure 90% precision
        var isUser = rows[i][1].toString().toLowerCase().trim() === searchName;
        // If checkAllFingers is true, we ignore the finger check for initial login.
        var isSameFinger = data.checkAllFingers ? true : (rows[i][11] === data.finger);
        
        if (isUser && isSameFinger) {
            record.userFound = true;
            if (rows[i][2] === "SYNC") {
                var x = parseFloat(rows[i][7]); // Absorbance
                var y = parseFloat(rows[i][5]);  // Actual Meter
                var u = parseFloat(rows[i][9]); // UpstrokeTime
                
                // Only include points with valid biological markers in the regression
                if (!isNaN(x) && !isNaN(y) && u > 40 && u < 300) {
                    syncPoints.push({ x: x, y: y, u: u });
                }
            }

            if (!record.foundLatest) { 
                record.lastFinger = rows[i][11]; // Capture which finger this data belongs to
                record.coefA = parseFloat(rows[i][13]) || record.coefA;
                record.coefB = parseFloat(rows[i][14]) || record.coefB;
                record.intercept = parseFloat(rows[i][15]) || record.intercept;
                record.personalOffset = parseFloat(rows[i][16]) || 0;
                record.foundLatest = true;
            }
            if (syncPoints.length >= 40) break;
        }
    }
    syncPoints.reverse();
    
    // NEW: OUTLIER REJECTION AI (Phase 4)
    syncPoints = syncPoints.filter(p => !(p.x < 0.1 && p.y > 180));
    
    record.syncCount = syncPoints.length;

    // Smart Logic: Quadratic Regression for 20+ Syncs
    if (syncPoints.length >= 20) {
        var n = syncPoints.length;
        var sX=0, sX2=0, sX3=0, sX4=0, sY=0, sXY=0, sX2Y=0;
        syncPoints.forEach(p => {
            var x = p.x, y = p.y, x2 = x*x;
            sX += x; sX2 += x2; sX3 += x2*x; sX4 += x2*x2;
            sY += y; sXY += x*y; sX2Y += x2*y;
        });

        var det = (n * (sX2 * sX4 - sX3 * sX3) - sX * (sX * sX4 - sX2 * sX3) + sX2 * (sX * sX3 - sX2 * sX2));
        if (Math.abs(det) > 1e-6) {
            var a = (n * (sX2 * sX2Y - sX3 * sXY) - sX * (sX * sX2Y - sX2 * sXY) + sY * (sX * sX3 - sX2 * sX2)) / det;
            // Sanity Check: If 'a' is positive, it's an upward curve (wrong for PPG). 
            // We only apply if 'a' is negative or near zero.
            if (a < 10) { 
               record.coefA = a;
               record.coefB = (n * (sXY * sX4 - sX2Y * sX3) - sY * (sX * sX4 - sX2 * sX3) + sX2 * (sX * sX2Y - sXY * sX2)) / det;
               record.intercept = (sY * (sX2 * sX4 - sX3 * sX3) - sX * (sXY * sX4 - sX2Y * sX3) + sX2 * (sXY * sX3 - sX2Y * sX2)) / det;
            }
        }
    } 
    // NEW: Intermediate Logic (Linear Fit with Fixed Curve) for 5-19 Syncs
    // This allows the system to learn the user's sensitivity (Slope) much earlier than 20 syncs.
    else if (syncPoints.length >= 5) {
        var n = syncPoints.length;
        var sumW = 0, sumWX = 0, sumWY = 0, sumWXY = 0, sumWX2 = 0;
        var fixedA = 12.5;

        syncPoints.forEach(p => {
            // AI WEIGHTING: Trust points more if they have a "human-like" upstroke
            var weight = (p.u > 100 && p.u < 140) ? 1.5 : 1.0;
            
            var x = p.x;
            var y_prime = p.y - (fixedA * x * x);
            
            sumW += weight;
            sumWX += weight * x;
            sumWX2 += weight * x * x;
            sumWY += weight * y_prime;
            sumWXY += weight * x * y_prime;
        });

        var det = (sumW * sumWX2) - (sumWX * sumWX);
        if (Math.abs(det) > 1e-6) {
            record.coefA = fixedA;
            record.coefB = ((sumW * sumWXY) - (sumWX * sumWY)) / det;
            record.intercept = ((sumWY * sumWX2) - (sumWX * sumWXY)) / det;
        }
    }
    
    // ALWAYS calculate Personal Offset (Residual Correction)
    // This ensures the model "snaps" to the latest sync even if the regression curve is rigid.
    if (syncPoints.length >= 1) {
        var currentOffset = 0;
        syncPoints.forEach((p, idx) => {
            var pred = (record.coefA * Math.pow(p.x, 2)) + (record.coefB * p.x) + record.intercept;
            var error = p.y - pred;
            // Dynamic Learning Rate: Trust recent data (0.8) more than old history
            var learningRate = 0.8; 
            currentOffset = (idx === 0) ? error : (currentOffset * (1 - learningRate)) + (error * learningRate);
        });
        record.personalOffset = currentOffset; 
    }
    return ContentService.createTextOutput(JSON.stringify(record)).setMimeType(ContentService.MimeType.JSON);
  }

  // SAVE LOGIC
  var cA = data.coefA || 12.5;
  var cB = data.coefB || 45.0;
  var cI = data.intercept || 65.0;
  var offset = (data.offset !== undefined) ? data.offset : (data.personalOffset || 0);

  sheet.appendRow([
    new Date(), data.name, data.type, data.val, data.raw, data.actual, 
    data.noise, data.absorbance, data.perfusionIndex, 
    isValidBio ? upstroke : "ERR", // Mark junk data clearly in the sheet
    data.bpm, data.finger, data.hba1c, cA, cB, 
    cI, offset, data.waveform
  ]);
  return ContentService.createTextOutput("Success");
}
